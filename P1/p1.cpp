/**
 * @author  Hongru He
 * @date    04/19/2024
 * @version 1.0
 * @file    p1.cpp - a pixel game using multi-threads, mutex, barrier, and
 * atomic flag.
 * This game has several objects bounce within a range and will terminate
 * each other by collision. It also has an object could be only generated by
 * specific user key input. User can choose to quit at any point if there is
 * no active user-generate object.
 * @extra_credit    I think my program warrants more complex play extra
 * credit because, besides the interaction between objects, my game also
 * allows user to control the generation of one kind of object. That is an
 * additional game logic which could be developed into a more complete game
 * if given enough time. I also think my program warrants Nifty Critters
 * extra credit because I have 4 classes and up to 8 objects rendered in
 * different shapes and colors to distinguish them and make this game content
 * understandable visually.
 */

#include <iostream>
#include <future>
#include <barrier>
#include "Terminal.h"
#include "MovingObj.h"
#include "Monster.h"
#include "Cannon.h"
#include "CannonBall.h"

using namespace std;

/**
 * @class ScreenManager handles the game play, synchronizing with the other threads
 */
class ScreenManager {
public:
    ScreenManager(MovingObj *worm, PixelMatrix *pxm, mutex *m, barrier<>
            *b,
                  int t = 0)
            : time(t), worm(worm), pxm(pxm), lock(m), meetup(b) {}

    /**
     * This is the method running in the threads.
     * @return number of generations drawn
     */
    int play() {
        int generations = 0;
        while (!stop.test()) {
            generations++;

            // paint myself on the canvas (but avoid "mixed bodies" with the mutex)
            lock->lock();
            if (generations >= time) {
                worm->render(*pxm);
            }
            lock->unlock();

            // once we've all met up, all the rendering is done; wait for resumption point
            meetup->arrive_and_wait();

            // once the previous generation has been painted, move worm to next state
            meetup->arrive_and_wait();
            if (generations >= time) {
                worm->move();
            }
        }
        meetup->arrive_and_drop();
        return generations;
    }

public:
    atomic_flag stop;

private:
    int time;
    MovingObj *worm;
    PixelMatrix *pxm;
    mutex *lock;
    barrier<> *meetup;
};

/**
 * @class CannonManager handles the cannon display, synchronizing with the
 * other threads
 */
class CannonManager {
public:
    CannonManager(Cannon *gun, PixelMatrix *pxm, mutex *m, barrier<> *b)
                            : gun(gun), pxm(pxm), lock(m), meetup(b) {};

    int display() {
        int generations = 0;
        while (!stop.test()) {
            generations++;

            // paint myself on the canvas (but avoid "mixed bodies" with the mutex)
            lock->lock();
            gun->render(*pxm);
            lock->unlock();

            // once we've all met up, all the rendering is done; wait for resumption point
            meetup->arrive_and_wait();

            // once the previous generation has been painted, move worm to next state
            meetup->arrive_and_wait();
        }
        meetup->arrive_and_drop();
        return generations;
    }

public:
    atomic_flag stop;

private:
    Cannon *gun;
    PixelMatrix *pxm;
    mutex *lock;
    barrier<> *meetup;
};

/**
 * @class CannonBallManager handles the cannonball shot, synchronizing with the
 * other threads
 */
class CannonBallManager {
public:
    CannonBallManager(CannonBall *ball, PixelMatrix *pxm, mutex *m, barrier<> *b)
            : ball(ball), pxm(pxm), lock(m), meetup(b), stop(false) {};

    int shot() {
        try {
            while (!stop) { // Continue until the stop flag is set
                // Lock the mutex before rendering
                lock_guard<mutex> guard(*lock);
                ball->render(*pxm); // Render the cannonball

                // Move the cannonball
                ball->move();

                if (ball->isStoppedStatus()) {
                    stop = true; // Stop the ScreenManager if the cannonball is stopped
                }

                // Synchronize with the barrier
                meetup->arrive_and_wait();
            }

        } catch (const std::exception &e) {
            cerr << "Error: " << e.what() << endl; // Log errors
        }

        return 0;
    }

    void terminate() {
        stop = true; // Signal to stop
    }

private:
    CannonBall *ball; // Reference to the cannonball
    PixelMatrix *pxm; // Pixel matrix for rendering
    mutex *lock; // Mutex for thread safety
    barrier<> *meetup; // Barrier for synchronization
    atomic<bool> stop; // Atomic flag to indicate stop
};

/**
 * @class MyWriggler initializes and handles a vector of MovingObj instances
 * using ScreenManager
 */
class MyWriggler {
public:
    MovingObj wiggler;
    ScreenManager manager;
    future<int> handle;

    MyWriggler(
            int startRow, int startCol, int limitR, int limitC,
            PixelMatrix *pxm, mutex *m, barrier<> *meetup, int time = 0
    ) : wiggler(startRow, startCol, limitR, limitC),
        manager(&wiggler, pxm, m, meetup, time),
        handle(async(&ScreenManager::play,
                     &manager)) {}
};

/**
 * main thread
 */
int main() {
    const RGB BG_COLOR = RGB::BLACK;
    const int WAIT_TIME = 2;  // seconds to wait before starting
    const int THROTTLE = 50;  // milliseconds of pause between generations

    cout << "Quit this game by typing Q key." << endl;
    cout << "Shot the cannonball by typing Space key." << endl;
    this_thread::sleep_for(chrono::seconds(WAIT_TIME));

    // set up the terminal and the pixel matrix feeding it
    auto *t = new Terminal(false);  // false: makes hasKey work as expected
    int rows, cols;
    t->getSize(rows, cols);
    PixelMatrix pxm(rows, cols, BG_COLOR);

    // set up the synchronization
    barrier meetup(7);
    barrier cannonSystem(2);    // EC: SET UP A SEPARATE BARRIER
    mutex lock;
    mutex cannonLock;

    // set up the cannon
    Cannon cannon(cols / 2, rows - 1);
    CannonManager gunManager(&cannon, &pxm, &cannonLock, &cannonSystem);
    future<int> gunHandle = async(&CannonManager::display, &gunManager);

    // set up the limit of the cannonball
    int cannonBallLimit = 0;
    bool isCannonBallActive = false;
    CannonBall *cannonball = nullptr;
    CannonBallManager *ballManager = nullptr;
    future<int> cannonBallHandle;

    // set up MovingObj instances and the Monster instance
    vector<MyWriggler *> myWrigglers;
    for (int i = 0; i < 5; i++) {
        myWrigglers.push_back(
                new MyWriggler(rows / 7 * (i + 1), 5, rows, cols, &pxm, &lock,
                               &meetup, 10 * i));
    }
    Monster jill(rows / 5 * 2, cols / 5 * 2, rows, cols);
    ScreenManager jillManager(&jill, &pxm, &lock, &meetup);
    future<int> jillHandle = async(&ScreenManager::play, &jillManager);

    // Game logic
    bool continueGame = true;
    while (continueGame) {
        if (t->hasKey()) {
            char ch = t->getKey();
            // only quit if there is no active cannonball
            if (ch == 'q' && !isCannonBallActive) {
                continueGame = false;
            }

            // how users could generate cannonball
            if (ch == ' ' && !isCannonBallActive) {
                cannonball = new CannonBall(cols / 2, rows - 1,
                                            cannonBallLimit);
                ballManager = new CannonBallManager(cannonball, &pxm,
                                                    &cannonLock, &cannonSystem);
                cannonBallHandle = async(&CannonBallManager::shot, ballManager);
                isCannonBallActive = true;
            }
        }
        // how the MovingObj and Monster interact
        else {
            for (int i = 0; i < 5; i++) {
                // Make sure these MovingObj only terminated when they get
                // across with Monster's mouth
                if (myWrigglers[i]->wiggler.getCol() + 9 > jill.getCol() &&
                        myWrigglers[i]->wiggler.getCol() <= jill.getCol() + 8 &&
                        jill.getRow() + 3 == myWrigglers[i]->wiggler.getRow()) {
                    myWrigglers[i]->manager.stop.test_and_set();
                }
            }

            if (cannonball && cannonball->isStoppedStatus()) {
                isCannonBallActive = false;
            }

            this_thread::sleep_for(chrono::milliseconds(
                    THROTTLE)); // Pause for human visibility
            meetup.arrive_and_wait();  // Main thread waits for everyone to render
            cannonSystem.arrive_and_wait(); // Cannon and cannonball wait
            t->paint(pxm); // Paint the rendered pixel matrix
            pxm.paint(0, 0, rows, cols,
                      BG_COLOR);  // Clear screen for next render
            cannonSystem.arrive_and_wait(); // Release Cannon system
            meetup.arrive_and_wait();  // Now release everyone from their second wait
        }
    }

    // tell the remaining objects to stop
    for (int i = 0; i < 5; i++) {
        myWrigglers[i]->manager.stop.test_and_set();
    }
    jillManager.stop.test_and_set();
    gunManager.stop.test_and_set();

    // make sure nobody is stuck at the barrier
    cannonSystem.arrive_and_wait();
    cannonSystem.arrive_and_wait();
    meetup.arrive_and_wait(); // first stop
    meetup.arrive_and_wait(); // second stop

    // keep final screen up for a second
    this_thread::sleep_for(chrono::seconds(WAIT_TIME));

    // get the wrigglers' values
    int jillPlayed = jillHandle.get();
    int gunDisplayed = gunHandle.get();

    delete t;  // destruction of the Terminal object returns the screen to normal shell mode

    cout << "Jill wiggled " << jillPlayed << " times!" << endl;
    for (int i = 0; i < 5; i++) {
        int wrigglerPlayed = myWrigglers[i]->handle.get();
        cout << "Wriggler " << i << " wriggled " << wrigglerPlayed <<
        " times!" << endl;
    }
    cout << "Cannon displayed " << gunDisplayed << " times!" << endl;
    return EXIT_SUCCESS;
}
